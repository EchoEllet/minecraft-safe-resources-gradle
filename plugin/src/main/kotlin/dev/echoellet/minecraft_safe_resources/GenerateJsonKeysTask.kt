package dev.echoellet.minecraft_safe_resources

import com.google.gson.JsonParser
import org.gradle.api.DefaultTask
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputFile
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction
import java.io.File

/**
 * Generates a Java or Kotlin object that contains all the keys from a JSON file
 * to reference them in a type-safe way.
 */
abstract class GenerateJsonKeysTask : DefaultTask() {
    @get:InputFile
    abstract val inputResourceFile: RegularFileProperty

    @get:Input
    abstract val outputClassDescription: Property<String>

    @get:Input
    abstract val outputClassName: Property<String>

    @get:Input
    abstract val outputLanguage: Property<OutputLanguage>

    @get:Input
    abstract val outputPackage: Property<String>

    @get:Input
    abstract val keyNamespaceToStrip: Property<String>

    @get:OutputDirectory
    val genOutputDir: DirectoryProperty = project.objects.directoryProperty().convention(
        project.layout.buildDirectory.dir(
            project.provider {
                val langDir = when (outputLanguage.get()) {
                    OutputLanguage.JAVA -> "java"
                    OutputLanguage.KOTLIN -> "kotlin"
                }
                "generated/${name}/src/main/$langDir"
            }
        )
    )

    init {
        group = "generation"
    }

    @TaskAction
    fun generate() {
        description = outputClassDescription.get()
        val taskName = this.name

        val cachedInputResourceFile = inputResourceFile.get()

        val file = inputResourceFile.get().asFile
        if (!file.exists()) {
            error("The input resource file for the task '$taskName' does not exist: '${file.path}'")
        }
        val cachedOutputLang = outputLanguage.get()
        val cachedOutputClassName = outputClassName.get()
        val cachedOutputPackage = outputPackage.get()
        val cachedOutputClassDescription = outputClassDescription.get()

        val keys = parseKeys(file)

        val outputFile = genOutputDir.get().asFile
            .resolve(cachedOutputPackage.replace('.', '/'))
            .apply { mkdirs() }
            .resolve(getOutputFileName(cachedOutputClassName, cachedOutputLang))
        outputFile.parentFile.mkdirs()

        generateOutputClassFile(outputFile, keys, cachedOutputClassDescription, cachedOutputLang)

        println("Generated `$outputClassName` from resource asset: ${cachedInputResourceFile.asFile.path}")
    }

    private fun getGeneratedConstantKeyLine(
        outputLanguage: OutputLanguage,
        constName: String,
        keyValue: String,
    ): String {
        return when (outputLanguage) {
            OutputLanguage.JAVA -> "public static final String $constName = \"$keyValue\";"
            OutputLanguage.KOTLIN -> "const val $constName = \"$keyValue\""
        }
    }

    private fun generateOutputClassFile(
        outputFile: File,
        keys: Map<String, String>,
        outputClassDescription: String,
        outputLanguage: OutputLanguage,
    ) {
        val generatedConstants = keys.map { (constName, keyValue) ->
            "    ${getGeneratedConstantKeyLine(outputLanguage, constName, keyValue)}"
        }
        val cachedOutputPackage = outputPackage.get()
        val cacheOutputClassName = outputClassName.get()

        val taskName = this.name
        // TODO: Test Kotlin gen, actually test both
        val fileText = when (outputLanguage) {
            OutputLanguage.JAVA -> """
                |package $cachedOutputPackage;
                |
                |import org.jetbrains.annotations.ApiStatus;
                |
                |${
                outputClassDescription
                    .lines()
                    .joinToString(separator = "\n/// ", prefix = "/// ")
            }
                |///
                |/// This file is fully generated by Gradle scripts. Do not modify directly, as all changes will be reverted.
                |/// Update the task `${taskName}` in `build.gradle.kts` / `build.gradle` if needed.
                |@ApiStatus.Internal
                |public final class $cacheOutputClassName {
                |    private $cacheOutputClassName() {
                |    }
                |
                |${generatedConstants.joinToString("\n")}
                |}
            """.trimMargin()

            OutputLanguage.KOTLIN -> """
                |package $cachedOutputPackage
                |
                |import org.jetbrains.annotations.ApiStatus
                |
                |/**
                |${
                outputClassDescription
                    .lines()
                    .joinToString(separator = "\n * ", prefix = " * ")
            }
                | *
                | * This file is fully generated by Gradle scripts. Do not modify directly, as all changes will be reverted.
                | * Update the task `${taskName}` in `build.gradle.kts` / `build.gradle` if needed.
                | */
                |@ApiStatus.Internal
                |object $cacheOutputClassName {
                |${generatedConstants.joinToString("\n")}
                |}
            """.trimMargin()
        }
        outputFile.writeText(fileText)
    }

    private fun parseKeys(file: File): Map<String, String> {
        val parser = JsonParser.parseString(file.readText())
        val modId = keyNamespaceToStrip.get()
        return parser.asJsonObject.entrySet().associate { (key, _) ->
            val constName = key
                // Remove mod id if present
                .replace(".$modId", "", ignoreCase = true)
                // Convert camelCase to snake_case
                .replace(Regex("([a-z])([A-Z])"), "$1_$2")
                .replace(".", "_")
                .uppercase()

            constName to key
        }
    }

    private fun getOutputFileName(outputClassName: String, outputLanguage: OutputLanguage): String {
        return "${outputClassName}.${outputLanguage.fileExtension}"
    }
}
